#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
变量作用域：LEGB法则
    局部作用域-->嵌套作用域-->全局作用域-->内置作用域-->NameError
    局部作用域：
        局部变量：包含在def关键字定义的语句块中，即在函数中定义的变量。
        每当函数被调用时都会创建一个新的局部作用域。
        Python中也有递归，即自己调用自己，每次调用都会创建一个新的局部命名空间。
        在函数内部的变量声明，除非特别的声明为全局变量，否则均默认为局部变量。
        有些情况需要在函数内部定义全局变量，这时可以使用global关键字来声明变量的作用域为全局。
        局部变量域就像一个 栈，仅仅是暂时的存在，依赖创建该局部作用域的函数是否处于活动的状态。
        所以，一般建议尽量少定义全局变量，因为全局变量在模块文件运行的过程中会一直存在，占用内存空间。
        注意：如果需要在函数内部对全局变量赋值，需要在函数内部通过global语句声明该变量为全局变量。
    嵌套作用域：
        E也包含在def关键字中，E和L是相对的，E相对于更上层的函数而言也是L。与L的区别在于，
        对一个函数而言，L是定义在此函数内部的局部作用域，而E是定义在此函数的上一层父级函数的局部作用域。
        主要是为了实现Python的闭包，而增加的实现。
    全局作用域：
        即在模块层次中定义的变量，每一个模块都是一个全局作用域。
        也就是说，在模块文件顶层声明的变量具有全局作用域，从外部开来，模块的全局变量就是一个模块对象的属性。
        注意：全局作用域的作用范围仅限于单个模块文件内

        全局变量默认可读，如果需要改变全局变量的值，需要在函数内部使用global定义
        特殊：列表，字典，可修改，但不能重新赋值，如果需要重新赋值，需要在函数内部使用global定义全局变量

    内置作用域：
        系统内固定模块里定义的变量，如预定义在builtin 模块内的变量。


"""

# 全局变量a
a = 1


def foo():
    # 局部变量b,c
    b = 2
    c = 3
    # 在函数内部 如果需要重新改变全局变量的值，需要使用global进行定义
    # global a
    # a = 2
    print('locals: %s' % locals())
    return 'result: %d' % (a + b + c)


print(foo())
print('a =', a)


def my_foo():
    """
    这种内部函数的局部作用域中可以访问外部函数局部作用域中变量的行为，我们称为： 闭包。
    内部函数可以访问外部函数变量的特点很像将外部函数的变量直接“打包”到内部函数中一样，
    我们也可以这样理解闭包：将组成函数的语句以及执行这些语句的环境“打包”在一起时得到的对象称为闭包。
    :return:
    """
    aa = 1

    def bar():
        b = 2
        c = 3
        return aa + b + c
    return bar


foo1 = my_foo()
print(foo1())
print('a =', a)

